local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Stats = game:GetService("Stats")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
if not player then return end

local PingRemote = ReplicatedStorage:WaitForChild("Events", 30):WaitForChild("UpdatePing", 30)
if not PingRemote then return end

local Config = {
    Active = false,
    MinPing = 70,
    MaxPing = 90,
    UpdateTime = 2,
    DynamicMode = false,
    DynamicReduction = 60,
    MaxFails = 3,
    Timeout = 10,
    CheckInterval = 0.1,
    FailCount = 0,
    MossHelper = false,
    ShowHitbox = false,
    HeadSize = Vector3.new(2, 2, 2),
    HeadOffset = Vector3.new(0, 0.5, 0)
}

local Window = Rayfield:CreateWindow({
    Name = "React Plus",
    LoadingTitle = "React Plus",
    LoadingSubtitle = "by Jonuffy",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "ReactPlusConfig",
        FileName = "Config"
    },
    KeySystem = false,
    Theme = {
        TextColor = Color3.fromRGB(240, 240, 240),
        Background = Color3.fromRGB(15, 15, 15),
        Topbar = Color3.fromRGB(20, 20, 20),
        TabBackground = Color3.fromRGB(25, 25, 25),
        TabStroke = Color3.fromRGB(35, 35, 35),
        TabBackgroundSelected = Color3.fromRGB(30, 30, 30),
        ElementBackground = Color3.fromRGB(20, 20, 20),
        ElementBackgroundHover = Color3.fromRGB(25, 25, 25),
        ElementStroke = Color3.fromRGB(35, 35, 35),
        SliderBackground = Color3.fromRGB(25, 25, 25),
        SliderProgress = Color3.fromRGB(60, 60, 60),
        ToggleBackground = Color3.fromRGB(20, 20, 20),
        ToggleEnabled = Color3.fromRGB(0, 146, 214),
        ToggleDisabled = Color3.fromRGB(60, 60, 60),
        DropdownBackground = Color3.fromRGB(20, 20, 20)
    }
})

local ReactTab = Window:CreateTab("React", 4483362458)
local PingTab = Window:CreateTab("Ping", 4483362458)
local SettingsTab = Window:CreateTab("Settings", 4483362458)

local statusLabel = PingTab:CreateLabel("Status: Disabled")
local pingLabel = PingTab:CreateLabel("Your Ping: 0ms")

local function getRealPing()
    local success, ping = pcall(function()
        return math.floor(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())
    end)
    return success and ping or 0
end

local function updatePing()
    if not Config.Active then return end

    local clientPing = player.PlayerScripts:FindFirstChild("ClientPing")
    if clientPing then
        clientPing.Enabled = not Config.Active
    end

    local currentPing = getRealPing()
    local pingToSend = Config.DynamicMode and
        math.random(Config.MinPing, Config.MaxPing) or
        math.max(1, currentPing - Config.DynamicReduction)

    local success, err = pcall(function()
        PingRemote:FireServer(pingToSend)
    end)

    if not success then
        Config.FailCount = Config.FailCount + 1
        if Config.FailCount >= Config.MaxFails then
            Config.Active = false
            if clientPing then
                clientPing.Enabled = true
            end
            statusLabel:Set("Status: Error - Too many fails")
            Rayfield:Notify({
                Title = "Error",
                Content = "System disabled due to failures: " .. tostring(err),
                Duration = 3
            })
        end
    else
        Config.FailCount = 0
    end
end

local function startPingLoop()
    local startTime = tick()

    while not player:FindFirstChild('leaderstats') and tick() - startTime <= Config.Timeout do
        task.wait(Config.CheckInterval)
    end

    if not player:FindFirstChild('leaderstats') then
        Config.Active = false
        statusLabel:Set("Status: Error - Timeout")
        Rayfield:Notify({
            Title = "Error",
            Content = "System timeout - leaderstats not found",
            Duration = 3
        })
        return
    end

    if Config.Active then
        local clientPing = player.PlayerScripts:FindFirstChild("ClientPing")
        if clientPing then
            clientPing.Enabled = false
        end

        task.spawn(function()
            while Config.Active do
                updatePing()
                task.wait(Config.UpdateTime)
            end
        end)
    end
end

local function updateHeadSize()
    if not player.Character or not player.Character:FindFirstChild("Head") then return end

    local head = player.Character.Head
    local originalSize = Vector3.new(2, 2, 2)
    local originalTransparency = 0

    if Config.MossHelper then
        local currentPosition = head.Position
        head.Size = Config.HeadSize
        head.Position = currentPosition + Config.HeadOffset
        head.Transparency = 0.5
    else
        head.Size = originalSize
        head.Position = head.Position - Config.HeadOffset
        head.Transparency = originalTransparency
    end
end

local function createHitboxVisualizer()
    if not player.Character or not player.Character:FindFirstChild("Head") then return end

    local existingHitbox = player.Character:FindFirstChild("HitboxVisualizer")
    if existingHitbox then existingHitbox:Destroy() end

    local hitboxPart = Instance.new("Part")
    hitboxPart.Name = "HitboxVisualizer"
    hitboxPart.Anchored = false
    hitboxPart.CanCollide = false
    hitboxPart.Transparency = 0.6
    hitboxPart.BrickColor = BrickColor.new("Really red")
    hitboxPart.Material = Enum.Material.Neon
    hitboxPart.Size = player.Character.Head.Size

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hitboxPart
    weld.Part1 = player.Character.Head
    weld.Parent = hitboxPart

    hitboxPart.CFrame = player.Character.Head.CFrame
    hitboxPart.Parent = player.Character

    return hitboxPart
end

local function updateHitboxVisualizer()
    if not player.Character or not player.Character:FindFirstChild("Head") then return end

    local hitboxPart = player.Character:FindFirstChild("HitboxVisualizer")

    if Config.ShowHitbox then
        if not hitboxPart or not hitboxPart:FindFirstChild("WeldConstraint") then
            hitboxPart = createHitboxVisualizer()
        end
        hitboxPart.Size = player.Character.Head.Size
    else
        if hitboxPart then
            hitboxPart:Destroy()
        end
    end
end

ReactTab:CreateSection("Main Controls")

ReactTab:CreateToggle({
    Name = "Moss Helper",
    Info = "Modifies head size and position",
    CurrentValue = false,
    Flag = "ToggleMoss",
    Callback = function(Value)
        Config.MossHelper = Value
        updateHeadSize()
        updateHitboxVisualizer()
    end
})

ReactTab:CreateToggle({
    Name = "Show Hitbox",
    Info = "Displays head hitbox visualization",
    CurrentValue = false,
    Flag = "ToggleHitbox",
    Callback = function(Value)
        Config.ShowHitbox = Value
        updateHitboxVisualizer()
    end
})

ReactTab:CreateButton({
    Name = "Reset Size",
    Callback = function()
        Config.HeadSize = Vector3.new(2, 2, 2)
        if Config.MossHelper then
            updateHeadSize()
            updateHitboxVisualizer()
        end
    end
})

ReactTab:CreateButton({
    Name = "Reset Position",
    Callback = function()
        Config.HeadOffset = Vector3.new(0, 0.5, 0)
        if Config.MossHelper then
            updateHeadSize()
            updateHitboxVisualizer()
        end
    end
})

ReactTab:CreateSection("Head Configuration")

ReactTab:CreateInput({
    Name = "Head Size (X,Y,Z)",
    PlaceholderText = "2,2,2",
    RemoveTextAfterFocusLost = false,
    Flag = "HeadSize",
    Callback = function(Text)
        local x, y, z = Text:match("([^,]+)%s*,%s*([^,]+)%s*,%s*([^,]+)")
        x, y, z = tonumber(x), tonumber(y), tonumber(z)

        if x and y and z then
            Config.HeadSize = Vector3.new(
                math.clamp(x, 0.1, 100),
                math.clamp(y, 0.1, 100),
                math.clamp(z, 0.1, 100)
            )
            if Config.MossHelper then
                updateHeadSize()
                updateHitboxVisualizer()
            end
            return true
        end
        Rayfield:Notify({
            Title = "Invalid Input",
            Content = "Please use format: x,y,z (e.g. 2,2,2)",
            Duration = 3
        })
        return false
    end
})

ReactTab:CreateInput({
    Name = "Head Offset (X,Y,Z)",
    PlaceholderText = "0,0.5,0",
    RemoveTextAfterFocusLost = false,
    Flag = "HeadOffset",
    Callback = function(Text)
        local x, y, z = Text:match("([^,]+)%s*,%s*([^,]+)%s*,%s*([^,]+)")
        x, y, z = tonumber(x), tonumber(y), tonumber(z)

        if x and y and z then
            Config.HeadOffset = Vector3.new(
                math.clamp(x, -50, 50),
                math.clamp(y, -50, 50),
                math.clamp(z, -50, 50)
            )
            if Config.MossHelper then
                updateHeadSize()
                updateHitboxVisualizer()
            end
            return true
        end
        Rayfield:Notify({
            Title = "Invalid Input",
            Content = "Please use format: x,y,z (e.g. 0,0.5,0)",
            Duration = 3
        })
        return false
    end
})

PingTab:CreateSection("Controls")

local toggleReact = PingTab:CreateToggle({
    Name = "Enable React Plus",
    Info = "Toggles the system on/off",
    CurrentValue = Config.Active,
    Flag = "ToggleReact",
    Callback = function(Value)
        Config.Active = Value
        Config.FailCount = 0
        statusLabel:Set("Status: " .. (Value and "Enabled" or "Disabled"))

        if player.PlayerScripts:FindFirstChild("ClientPing") then
            player.PlayerScripts.ClientPing.Enabled = not Value
        end

        if Value then
            startPingLoop()
            Rayfield:Notify({Title = "Success", Content = "System enabled", Duration = 2})
        end
    end
})

local dynamicToggle = PingTab:CreateToggle({
    Name = "Dynamic Mode",
    Info = "Toggle between dynamic and reduction mode",
    CurrentValue = Config.DynamicMode,
    Flag = "ToggleDynamic",
    Callback = function(Value)
        Config.DynamicMode = Value
        if sliderReduction then
            sliderReduction.Instance.Visible = not Value
        end
        if sliderMin then
            sliderMin.Instance.Visible = Value
        end
        if sliderMax then
            sliderMax.Instance.Visible = Value
        end
    end
})

PingTab:CreateSection("Adjustments")

local sliderReduction = PingTab:CreateSlider({
    Name = "Reduction",
    Info = "Value to reduce from current ping",
    Range = {1, 1000},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = Config.DynamicReduction,
    Flag = "SliderReduction",
    Callback = function(Value)
        Config.DynamicReduction = Value
    end
})

local sliderMin = PingTab:CreateSlider({
    Name = "Minimum",
    Info = "Minimum ping (dynamic mode)",
    Range = {1, 1000},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = Config.MinPing,
    Flag = "SliderMinPing",
    Callback = function(Value)
        Config.MinPing = Value
        if Config.MinPing > Config.MaxPing then
            Config.MaxPing = Value
            if sliderMax then sliderMax:Set(Value) end
        end
    end
})

local sliderMax = PingTab:CreateSlider({
    Name = "Maximum",
    Info = "Maximum ping (dynamic mode)",
    Range = {1, 1000},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = Config.MaxPing,
    Flag = "SliderMaxPing",
    Callback = function(Value)
        Config.MaxPing = Value
        if Config.MaxPing < Config.MinPing then
            Config.MinPing = Value
            if sliderMin then sliderMin:Set(Value) end
        end
    end
})

SettingsTab:CreateSection("System")

SettingsTab:CreateSlider({
    Name = "Update Time",
    Info = "Interval between updates",
    Range = {0.1, 5},
    Increment = 0.1,
    Suffix = "s",
    CurrentValue = Config.UpdateTime,
    Flag = "UpdateTime",
    Callback = function(Value)
        Config.UpdateTime = Value
    end
})

SettingsTab:CreateSlider({
    Name = "Max Fails",
    Info = "Maximum fails before disable",
    Range = {1, 10},
    Increment = 1,
    CurrentValue = Config.MaxFails,
    Flag = "MaxFails",
    Callback = function(Value)
        Config.MaxFails = Value
    end
})

RunService.Heartbeat:Connect(function()
    if Config.Active then
        pingLabel:Set("Your Ping: " .. getRealPing() .. "ms")
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.End and not gameProcessed then
        Rayfield:Toggle()
    end
end)

if sliderReduction then sliderReduction.Instance.Visible = Config.DynamicMode end
if sliderMin then sliderMin.Instance.Visible = not Config.DynamicMode end
if sliderMax then sliderMax.Instance.Visible = not Config.DynamicMode end

Rayfield:LoadConfiguration()

player.CharacterAdded:Connect(function(char)
    local head = char:WaitForChild("Head", 10)
    if head then
        task.wait(0.1)
        if Config.MossHelper then
            updateHeadSize()
        end
        if Config.ShowHitbox then
            createHitboxVisualizer()
        end
    end
end)

player.CharacterRemoving:Connect(function()
    local hitboxPart = player.Character and player.Character:FindFirstChild("HitboxVisualizer")
    if hitboxPart then
        hitboxPart:Destroy()
    end
end)

RunService.Heartbeat:Connect(function()
    if Config.MossHelper and player.Character and player.Character:FindFirstChild("Head") then
        local head = player.Character.Head

        if not head.Size:FuzzyEq(Config.HeadSize) then
            updateHeadSize()
        end

        if Config.ShowHitbox then
            local hitboxPart = player.Character:FindFirstChild("HitboxVisualizer")
            if hitboxPart then
                hitboxPart.Size = head.Size
                if not hitboxPart:FindFirstChild("WeldConstraint") then
                    createHitboxVisualizer()
                end
            else
                createHitboxVisualizer()
            end
        end
    end
end)
